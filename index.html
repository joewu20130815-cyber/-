<!DOCTYPE html>
<html>
<head>
    <title>çƒ å®‡å®™</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: white; font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; overflow: hidden; }
        #overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,10,10,0.95); padding: 30px; border-radius: 20px; text-align: center; border: 2px solid #ff0000; z-index: 100; width: 320px; box-shadow: 0 0 50px rgba(255,0,0,0.3); }
        input { padding: 12px; border-radius: 8px; border: 1px solid #333; background: #111; color: #fff; width: 85%; margin: 10px 0; outline: none; }
        button { padding: 12px; background: #ff0000; color: white; border: none; cursor: pointer; border-radius: 8px; font-weight: bold; width: 95%; margin: 5px 0; transition: 0.3s; }
        button:hover { filter: brightness(1.2); }
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 15px; border-radius: 10px; border: 1px solid #ff0000; width: 180px; }
        #chat-box { position: absolute; bottom: 20px; left: 20px; width: 280px; background: rgba(0,0,0,0.6); pointer-events: auto; border-radius: 10px; overflow: hidden; border: 1px solid #333; }
        #chat-content { height: 120px; overflow-y: auto; padding: 10px; font-size: 0.9em; }
        #chat-input { width: 100%; background: #222; border: none; color: white; padding: 10px; outline: none; border-top: 1px solid #333; }
        #voice-btn { position: absolute; top: 20px; left: 20px; pointer-events: auto; padding: 10px; background: #111; border: 1px solid #ff0000; color: white; cursor: pointer; border-radius: 8px; }
    </style>
</head>
<body>

<div id="overlay">
    <h2 style="letter-spacing: 5px;">å®‡å®™å…¥å£</h2>
    <input type="text" id="user-name" placeholder="ç©å®¶æš±ç¨±" maxlength="10">
    <input type="text" id="room-id" placeholder="æˆ¿é–“ç·¨è™Ÿ (å¦‚ p123)" value="p123">
    <button onclick="startUniverse(true)">å»ºç«‹å®‡å®™ (æˆ¿ä¸»)</button>
    <button onclick="startUniverse(false)" style="background: #333;">åŠ å…¥å®‡å®™ (å®¢äºº)</button>
    <p id="status" style="font-size: 0.8em; color: #888;"></p>
</div>

<div id="ui-layer">
    <button id="voice-btn" onclick="toggleVoice()">èªéŸ³é€šè¨Š: é—œé–‰</button>
    <div id="leaderboard">
        <h4 style="margin:0 0 10px 0; color: #ff0000; text-align: center;">ğŸ† æ’è¡Œæ¦œ</h4>
        <div id="lb-list" style="font-size: 0.9em;"></div>
    </div>
    <div id="chat-box">
        <div id="chat-content"></div>
        <input type="text" id="chat-input" placeholder="æŒ‰ Enter èŠå¤©...">
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    let peer, conn, isHost, myId, myStream;
    let WORLD_SIZE = 10000;
    // å¾ç€è¦½å™¨ç·©å­˜è®€å–ç­‰ç´š
    let myLvl = parseInt(localStorage.getItem('game_lvl')) || 1;
    let myExp = 0;
    let myPos = { x: 0, y: 0, r: 30 + (myLvl * 2), name: "", id: "", lvl: myLvl, msg: "", msgTime: 0 };
    let players = {}, foods = [], conns = [];
    let mouse = { x: 0, y: 0 };
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    function startUniverse(hostMode) {
        const rId = document.getElementById('room-id').value.trim();
        const uName = document.getElementById('user-name').value.trim() || "ç¥ç§˜ç™½çƒ";
        if(!rId.startsWith('p')) return alert("ç·¨è™Ÿè«‹ä»¥ p é–‹é ­");
        
        myPos.name = uName;
        myPos.x = Math.random() * 8000 + 1000;
        myPos.y = Math.random() * 8000 + 1000;
        isHost = hostMode;
        
        peer = isHost ? new Peer(rId) : new Peer();

        peer.on('open', (id) => {
            myId = id; myPos.id = id;
            players[myId] = myPos;
            if(isHost) setupHost(); else setupClient(rId);
            document.getElementById('overlay').style.display = 'none';
            initGame();
        });

        peer.on('call', call => {
            call.answer(myStream);
            call.on('stream', stream => {
                const audio = new Audio();
                audio.srcObject = stream;
                audio.play();
            });
        });
    }

    async function toggleVoice() {
        try {
            myStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            document.getElementById('voice-btn').innerText = "ğŸ”Š èªéŸ³é€šè¨Š: é–‹å•Ÿ";
            if(isHost) conns.forEach(c => peer.call(c.peer, myStream));
            else if(conn) peer.call(conn.peer, myStream);
        } catch(e) { alert("è«‹å…è¨±éº¥å…‹é¢¨æ¬Šé™ä»¥ä½¿ç”¨èªéŸ³"); }
    }

    function setupHost() {
        for(let i=0; i<800; i++) foods.push({id: i, x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, c: `hsl(${Math.random()*360}, 70%, 60%)`});
        // åŸ‹ 50 é¡†çƒåœ¨è§’è½
        for(let i=0; i<50; i++) foods.push({id: 'gold_'+i, x: 9500 + Math.random()*300, y: 9500 + Math.random()*300, c: '#ffcc00'});

        peer.on('connection', c => {
            conns.push(c);
            c.on('data', data => {
                if(data.type === 'move') players[data.id] = data;
                if(data.type === 'chat') broadcast(data); 
                if(data.type === 'eat_food') foods = foods.filter(f => f.id !== data.foodId);
                if(data.type === 'kill') {
                    if(players[data.targetId]) {
                        players[data.targetId].r = 5; // æ¨™è¨˜æ­»äº¡
                        players[data.targetId].x = Math.random()*WORLD_SIZE;
                        players[data.targetId].y = Math.random()*WORLD_SIZE;
                    }
                }
            });
        });
        setInterval(() => {
            if(foods.length < 600) foods.push({id: Date.now(), x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, c: `hsl(${Math.random()*360}, 70%, 50%)`});
            broadcast({type: 'sync', players, foods});
        }, 50);
    }

    function setupClient(rId) {
        conn = peer.connect(rId);
        conn.on('data', data => {
            if(data.type === 'sync') {
                const oldR = myPos.r;
                players = data.players; foods = data.foods;
                // é‡ç”Ÿåˆ¤å®šï¼šå¦‚æœè¢« Host å¼·åˆ¶ç¸®å°ä»£è¡¨æ­»äº†
                if(players[myId] && players[myId].r === 5 && oldR > 10) {
                    myPos.r = 30 + (myLvl * 2);
                    myPos.x = players[myId].x; myPos.y = players[myId].y;
                }
            }
            if(data.type === 'chat') addChatMessage(data.name, data.text);
        });
    }

    function broadcast(data) { 
        if(isHost) conns.forEach(c => c.open && c.send(data)); 
        else if(conn && conn.open) conn.send(data);
    }

    function initGame() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        window.onmousemove = e => { mouse.x = e.clientX - canvas.width/2; mouse.y = e.clientY - canvas.height/2; };
        document.getElementById('chat-input').onkeydown = e => {
            if(e.key === 'Enter' && e.target.value.trim()) {
                let txt = e.target.value;
                myPos.msg = txt; myPos.msgTime = Date.now();
                broadcast({type: 'chat', name: myPos.name, text: txt});
                e.target.value = '';
            }
        };
        loop();
    }

    function addChatMessage(name, text) {
        const chat = document.getElementById('chat-content');
        chat.innerHTML += `<div><span style="color:#ff0000">${name}:</span> ${text}</div>`;
        chat.scrollTop = chat.scrollHeight;
    }

    function loop() {
        let d = Math.sqrt(mouse.x**2 + mouse.y**2);
        if(d > 5) {
            let speed = Math.max(1.2, 110 / myPos.r);
            myPos.x = Math.max(0, Math.min(WORLD_SIZE, myPos.x + (mouse.x/d) * speed));
            myPos.y = Math.max(0, Math.min(WORLD_SIZE, myPos.y + (mouse.y/d) * speed));
        }

        // åƒçƒ & å‡ç´š
        foods.forEach((f, i) => {
            if(Math.hypot(myPos.x - f.x, myPos.y - f.y) < myPos.r) {
                myPos.r += (15 / myPos.r);
                myExp += 2;
                if(myExp > myLvl * 100) { 
                    myLvl++; myExp = 0; 
                    localStorage.setItem('game_lvl', myLvl); // å­˜å…¥ç·©å­˜
                    myPos.lvl = myLvl;
                }
                if(isHost) foods.splice(i, 1); else broadcast({type: 'eat_food', foodId: f.id});
            }
        });

        // äº’åƒ
        Object.values(players).forEach(p => {
            if (p.id !== myId && p.r > 10) {
                let dist = Math.hypot(myPos.x - p.x, myPos.y - p.y);
                if (dist < myPos.r && myPos.r > p.r * 1.1) {
                    myPos.r += p.r * 0.3;
                    broadcast({type: 'kill', targetId: p.id});
                }
            }
        });

        // æ’è¡Œæ¦œ
        let sorted = Object.values(players).sort((a,b) => b.r - a.r).slice(0, 5);
        document.getElementById('lb-list').innerHTML = sorted.map((p, i) => 
            `<div style="margin:5px 0;">${i+1}. ${p.name} <span style="color:#ffcc00; font-size:0.8em;">Lv.${p.lvl}</span></div>`
        ).join('');

        players[myId] = myPos;
        broadcast({type: 'move', ...myPos});
        render();
        requestAnimationFrame(loop);
    }

    function render() {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
        let zoom = Math.pow(30/myPos.r, 0.25);
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(zoom, zoom); ctx.translate(-myPos.x, -myPos.y);

        // ç¶²æ ¼
        ctx.strokeStyle = '#111'; ctx.lineWidth = 4;
        for(let i=0; i<=WORLD_SIZE; i+=500) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,WORLD_SIZE); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(WORLD_SIZE,i); ctx.stroke();
        }

        foods.forEach(f => { ctx.fillStyle = f.c; ctx.beginPath(); ctx.arc(f.x,f.y,12,0,7); ctx.fill(); });

        Object.values(players).forEach(p => {
            if(p.r < 10) return;
            let currentR = (p.id === myId) ? myPos.r : p.r;
            
            // é«˜ç­‰ç´šç™¼å…‰ç‰¹æ•ˆ
            if(p.lvl >= 5) {
                ctx.shadowBlur = 20 + p.lvl;
                ctx.shadowColor = (p.id === myId) ? '#fff' : '#ff0000';
            }

            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(p.x, p.y, currentR, 0, 7); ctx.fill();
            ctx.shadowBlur = 0;
            
            ctx.fillStyle = '#fff'; ctx.font = `bold ${14+currentR/6}px Arial`; ctx.textAlign = 'center';
            ctx.fillText(p.name, p.x, p.y - currentR - 15);
            
            // èŠå¤©æ³¡æ³¡
            if(p.msg && Date.now() - p.msgTime < 4000) {
                ctx.font = `bold ${12+currentR/8}px Arial`;
                ctx.fillText(p.msg, p.x, p.y - currentR - 45);
            }
        });
    }
</script>
</body>
</html>
