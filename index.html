import cv2
import numpy as np
import pyautogui
import mss
import time
import keyboard
import math
import pygetwindow as gw

# --- 核心參數 ---
WINDOW_TITLE = "FEAR UNIVERSE" # 請確保你的網頁標題包含這個詞
SCALE_FACTOR = 0.5             # 降採樣比例 (0.5 代表運算量減少 75%)
LOCK_SMOOTHING = 0.94          # 移動平滑度
PURSUIT_DELAY = 0.15           # 追擊餘輝 (秒)
MIN_BALL_AREA = 100            # 實心球最小面積 (縮小後的值)

# 關閉 pyautogui 安全防護，避免邊緣碰撞報錯
pyautogui.FAILSAFE = False

# --- 初始化記憶變數 ---
running = True
last_target_pos = None
last_target_time = 0

print(f">>> Fear 性能優化版啟動！")
print(f">>> 模式：降採樣運算 + 精準屏蔽 + 獵人專注")

# 視窗定位
all_wins = gw.getWindowsWithTitle(WINDOW_TITLE)
if not all_wins:
    print("找不到視窗！請檢查網頁標題。")
    exit()

target_win = all_wins[0]
sct = mss.mss()

try:
    while True:
        # 1. 系統控制
        if keyboard.is_pressed('q'): break
        if keyboard.is_pressed('p'):
            running = not running
            print(f"狀態: {'執行中' if running else '暫停'}")
            time.sleep(0.3)
        if not running:
            time.sleep(0.1)
            continue

        # 2. 高速擷取與降採樣 (性能關鍵)
        win_rect = {"top": target_win.top, "left": target_win.left, "width": target_win.width, "height": target_win.height}
        raw_shot = np.array(sct.grab(win_rect))[:, :, :3]
        
        # 縮小畫面進行處理，極大減輕 1050 負擔
        small_img = cv2.resize(raw_shot, (0, 0), fx=SCALE_FACTOR, fy=SCALE_FACTOR)
        hsv = cv2.cvtColor(small_img, cv2.COLOR_BGR2HSV)
        
        H, W = small_img.shape[:2]
        center_x, center_y = W // 2, H // 2
        current_time = time.time()

        # 3. 視覺掩膜
        # 抓取白色 (球體)
        white_mask = cv2.inRange(hsv, np.array([0, 0, 230]), np.array([180, 20, 255]))
        # 抓取綠色 (刺球)
        virus_mask = cv2.inRange(hsv, np.array([40, 100, 100]), np.array([80, 255, 255]))

        # --- 精準自我屏蔽 (圍繞中心填滿) ---
        cnts, _ = cv2.findContours(white_mask.copy(), cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in cnts:
            # 計算該色塊邊緣離中心點的距離
            dist = cv2.pointPolygonTest(c, (center_x, center_y), True)
            # 如果中心點在輪廓內，或距離極近 (自己或分身)
            if dist > -20:
                # 取得包圍圓並向外擴張屏蔽 (覆蓋名字與邊緣)
                (x, y), r = cv2.minEnclosingCircle(c)
                cv2.circle(white_mask, (int(x), int(y)), int(r + 15), 0, -1)

        # 排除 UI 文字區
        white_mask[:int(H*0.12), :] = 0 
        white_mask[int(H*0.88):, :] = 0

        # 4. 威脅與目標分析
        threat_vec = np.array([0.0, 0.0])
        # 刺球避讓
        v_cnts, _ = cv2.findContours(virus_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in v_cnts:
            if cv2.contourArea(c) < 100: continue
            M = cv2.moments(c)
            if M["m00"] == 0: continue
            vx, vy = int(M["m10"]/M["m00"]), int(M["m01"]/M["m00"])
            d = math.hypot(vx - center_x, vy - center_y)
            if d < 100: # 縮小後的距離
                angle = math.atan2(vy - center_y, vx - center_x)
                threat_vec -= np.array([math.cos(angle), math.sin(angle)]) * (100 - d) * 4

        # 實心球搜尋
        best_target = None
        max_prio = -1
        f_cnts, _ = cv2.findContours(white_mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        for c in f_cnts:
            area = cv2.contourArea(c)
            if area > MIN_BALL_AREA:
                M = cv2.moments(c)
                if M["m00"] == 0: continue
                fx, fy = int(M["m10"]/M["m00"]), int(M["m01"]/M["m00"])
                d = math.hypot(fx - center_x, fy - center_y)
                
                # 權重計算
                prio = area / (d**1.1 + 1)
                if prio > max_prio:
                    max_prio = prio
                    best_target = (fx, fy)

        # 5. 決策邏輯
        if np.linalg.norm(threat_vec) > 0.1:
            tx, ty = center_x + threat_vec[0]*80, center_y + threat_vec[1]*80
            last_target_pos = None
        elif best_target:
            tx, ty = best_target
            last_target_pos = (tx, ty)
            last_target_time = current_time
        elif last_target_pos and (current_time - last_target_time) < PURSUIT_DELAY:
            tx, ty = last_target_pos
        else:
            # 隨機巡航
            tx = center_x + math.cos(current_time * 0.5) * 150
            ty = center_y + math.sin(current_time * 0.5) * 150

        # 6. 座標還原與移動執行
        # 將降採樣後的座標 tx, ty 還原回原始解析度
        final_tx = (tx / SCALE_FACTOR) + target_win.left
        final_ty = (ty / SCALE_FACTOR) + target_win.top
        
        # 平滑移動
        cur_x, cur_y = pyautogui.position()
        move_x = cur_x + (final_tx - cur_x) * LOCK_SMOOTHING
        move_y = cur_y + (final_ty - cur_y) * LOCK_SMOOTHING
        
        pyautogui.moveTo(move_x, move_y, _pause=False)

except Exception as e:
    print(f"核心出錯: {e}")
