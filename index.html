<!DOCTYPE html>
<html>
<head>
    <title>çƒ å®‡å®™</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { margin: 0; background: #000; color: white; font-family: 'å¾®è»Ÿæ­£é»‘é«”', sans-serif; overflow: hidden; }
        #overlay { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(10,10,10,0.95); padding: 30px; border-radius: 20px; text-align: center; border: 2px solid #ff0000; z-index: 100; width: 350px; }
        input { padding: 12px; border-radius: 8px; border: 1px solid #333; background: #111; color: #fff; width: 85%; margin: 10px 0; outline: none; }
        button { padding: 12px; background: #ff0000; color: white; border: none; cursor: pointer; border-radius: 8px; font-weight: bold; width: 95%; margin: 5px 0; }
        
        #ui-layer { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
        #leaderboard { position: absolute; top: 20px; right: 20px; background: rgba(0,0,0,0.7); padding: 15px; border: 1px solid #fff; width: 220px; pointer-events: auto; }
        #chat-box { position: absolute; bottom: 20px; left: 20px; width: 320px; background: rgba(0,0,0,0.6); pointer-events: auto; border-radius: 10px; border: 1px solid #333; }
        #chat-content { height: 150px; overflow-y: auto; padding: 10px; font-size: 0.85em; color: #ccc; }
        #chat-input { width: 100%; background: #222; border: none; color: white; padding: 12px; outline: none; box-sizing: border-box; border-radius: 0 0 10px 10px; }
        #status-bar { position: absolute; top: 20px; left: 20px; font-size: 0.9em; text-shadow: 2px 2px #000; }
    </style>
</head>
<body>

<div id="overlay">
    <h1 style="margin:0; letter-spacing:5px; color:#ff0000;">è³¼ç¥¨è™•</h1>
    <p style="font-size:0.8em; color:#888;">???</p>
    <input type="text" id="user-name" placeholder="è¼¸å…¥æš±ç¨± (é è¨­ Fear(ä¸å‡†ç”¨fear(ai)!))" maxlength="15">
    <input type="text" id="room-id" placeholder="æˆ¿é–“ç·¨è™Ÿ" value="p123">
    <button onclick="startUniverse(true)">å»ºç«‹å®‡å®™ (Host)</button>
    <button onclick="startUniverse(false)" style="background: #333;">åŠ å…¥å®‡å®™ (Client)</button>
    <p style="font-size: 0.7em; color: #555;">[W] å™´æ°£åŠ é€Ÿ | [Space] åˆ†è£‚ | [Enter] èŠå¤©</p>
</div>

<div id="ui-layer">
    <div id="status-bar">
        <div id="level-display">ç­‰ç´š: Lv.1</div>
        <div id="death-display">æ­»äº¡å ´æ•¸: 0</div>
    </div>
    <div id="leaderboard">
        <h4 style="margin:0 0 10px 0; text-align: center; border-bottom:1px solid #555;">ğŸ† å…¨å®‡å®™æ’è¡Œ</h4>
        <div id="lb-list"></div>
    </div>
    <div id="chat-box">
        <div id="chat-content"></div>
        <input type="text" id="chat-input" placeholder="æŒ‰ Enter èªªè©±...">
    </div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    let peer, conn, isHost, myId, myStream;
    const WORLD_SIZE = 100000, GRID_SIZE = 6000;
    let myCells = []; 
    let players = {}, foods = [], conns = [], bots = [];
    let mouse = { x: 0, y: 0 };
    let BOT_NAMES = ["ä¸€å€‹ä¸æœƒä½é ­çš„ç”·äºº", "èˆ‡ç”Ÿä¿±ä¾†ç‹è€…æ°£æ¯", "å–®æ£"];
    
    // æ­»äº¡è®Šæ•¸å¾å¿«å–è®€å–
    let deathCount = parseInt(localStorage.getItem('fear_deaths')) || 0;
    let myLevel = Math.floor(deathCount / 10) + 1;

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // è‡ªå‹•è®€å–åŒç›®éŒ„ names.txt (5KB å°èœä¸€ç¢Ÿ)
    async function autoLoadNames() {
        try {
            const resp = await fetch('names.txt');
            if (resp.ok) {
                const text = await resp.text();
                const loaded = text.split(/\r?\n/).map(n => n.trim()).filter(n => n.length > 0);
                if (loaded.length > 0) BOT_NAMES = loaded;
                console.log("é¦¬ç”²æ³¨å…¥æˆåŠŸ:", BOT_NAMES.length);
            }
        } catch(e) { console.log("æœªåµæ¸¬åˆ° names.txtï¼Œä½¿ç”¨é è¨­åå–®"); }
    }

    async function startUniverse(hostMode) {
        isHost = hostMode;
        if(isHost) await autoLoadNames();
        
        // èªéŸ³åˆå§‹åŒ–
        try {
            myStream = await navigator.mediaDevices.getUserMedia({audio: true});
        } catch(e) { console.log("èªéŸ³ä¸å¯ç”¨"); }

        peer = isHost ? new Peer(document.getElementById('room-id').value) : new Peer();
        
        peer.on('open', id => {
            myId = id;
            myCells.push({ x: WORLD_SIZE/2, y: WORLD_SIZE/2, r: 60, vx: 0, vy: 0 });
            if(isHost) setupHost(); else setupClient(document.getElementById('room-id').value);
            document.getElementById('overlay').style.display = 'none';
            updateUI();
            initGame();
        });

        peer.on('call', call => {
            call.answer(myStream);
            call.on('stream', rem => { const a = new Audio(); a.srcObject = rem; a.play(); });
        });
    }

    function setupHost() {
        // ç”Ÿæˆé£Ÿç‰©èˆ‡ Bot
        for(let i=0; i<8000; i++) foods.push({id: i, x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE});
        for(let i=0; i<1500; i++) {
            let name = BOT_NAMES[i % BOT_NAMES.length];
            if(i >= BOT_NAMES.length) name += `_${Math.floor(i/BOT_NAMES.length)}`;
            bots.push({id: 'bot_'+i, x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, r: 35+Math.random()*45, name: name});
        }

        peer.on('connection', c => {
            conns.push(c);
            if(myStream) peer.call(c.peer, myStream);
            c.on('data', data => {
                if(data.type === 'grid_update') {
                    data.bots.forEach(upd => {
                        let b = bots.find(bt => bt.id === upd.id);
                        if(b) { b.x = upd.x; b.y = upd.y; b.r = upd.r; }
                    });
                }
                if(data.type === 'chat' || data.type === 'kill_notice') broadcast(data);
                if(data.type === 'move') players[data.id] = data;
                if(data.type === 'eat_food') foods = foods.filter(f => f.id !== data.foodId);
                if(data.type === 'spawn_food') { for(let i=0; i<data.count; i++) foods.push({id:Date.now()+i, x:Math.random()*WORLD_SIZE, y:Math.random()*WORLD_SIZE}); }
            });
        });
        setInterval(() => broadcast({type: 'sync', players, foods, bots}), 50);
    }

    function setupClient(rId) {
        conn = peer.connect(rId);
        conn.on('open', () => { if(myStream) peer.call(rId, myStream); });
        conn.on('data', data => {
            if(data.type === 'sync') { players = data.players; foods = data.foods; bots = data.bots; }
            if(data.type === 'chat') addChatMessage(data.name, data.msg, data.color);
            if(data.type === 'kill_notice') addChatMessage("ğŸ“¢ å®‡å®™å…¬å‘Š", data.msg, "#ffcc00");
        });
    }

    function broadcast(data) {
        if(isHost) {
            conns.forEach(c => c.open && c.send(data));
            if(data.type === 'chat') addChatMessage(data.name, data.msg, data.color);
            if(data.type === 'kill_notice') addChatMessage("ğŸ“¢ å®‡å®™å…¬å‘Š", data.msg, "#ffcc00");
        } else if(conn && conn.open) conn.send(data);
    }

    function addChatMessage(name, msg, color="#ff0000") {
        const div = document.createElement('div');
        div.innerHTML = `<b style="color:${color}">${name}:</b> <span style="color:#eee">${msg}</span>`;
        const content = document.getElementById('chat-content');
        content.appendChild(div);
        content.scrollTop = content.scrollHeight;
    }

    function updateUI() {
        document.getElementById('level-display').innerText = `éšç´š: Lv.${myLevel}`;
        document.getElementById('death-display').innerText = `æ­»äº¡å ´æ•¸: ${deathCount}`;
    }

    function handleDeath() {
        deathCount++;
        localStorage.setItem('fear_deaths', deathCount);
        myLevel = Math.floor(deathCount / 10) + 1;
        updateUI();
        myCells = [{ x: Math.random()*WORLD_SIZE, y: Math.random()*WORLD_SIZE, r: 60, vx:0, vy:0 }];
    }

    function initGame() {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        window.onmousemove = e => { mouse.x = e.clientX - canvas.width/2; mouse.y = e.clientY - canvas.height/2; };
        document.getElementById('chat-input').onkeydown = e => {
            if(e.key === 'Enter' && e.target.value.trim()) {
                broadcast({type:'chat', name: document.getElementById('user-name').value || "Fear", msg: e.target.value, color: "#00ff00"});
                e.target.value = '';
            }
        };
        window.onkeydown = e => {
            if(document.activeElement.id === 'chat-input') return;
            if(e.key === ' ') splitCells();
            if(e.key.toLowerCase() === 'w') jetSprint();
        };
        loop();
    }

    function jetSprint() {
        myCells.forEach(c => {
            if(c.r > 45) {
                c.r -= 2.5; let ang = Math.atan2(mouse.y, mouse.x);
                c.vx += Math.cos(ang)*30; c.vy += Math.sin(ang)*30;
                broadcast({type: 'spawn_food', count: 3});
            }
        });
    }

    function splitCells() {
        if(myCells.length >= 16) return;
        let newC = [];
        myCells.forEach(c => {
            if(c.r > 60) {
                c.r /= 1.414; let ang = Math.atan2(mouse.y, mouse.x);
                newC.push({ x: c.x, y: c.y, r: c.r, vx: Math.cos(ang)*50, vy: Math.sin(ang)*50 });
            }
        });
        myCells.push(...newC);
    }

    function loop() {
        myCells.forEach(c => {
            let d = Math.sqrt(mouse.x**2 + mouse.y**2), s = Math.max(2, 140/c.r);
            if(d > 5) { c.x += (mouse.x/d)*s + (c.vx||0); c.y += (mouse.y/d)*s + (c.vy||0); }
            c.vx *= 0.85; c.vy *= 0.85;
            c.x = Math.max(0, Math.min(WORLD_SIZE, c.x)); c.y = Math.max(0, Math.min(WORLD_SIZE, c.y));
            
            for(let i=foods.length-1; i>=0; i--) {
                if(Math.hypot(c.x-foods[i].x, c.y-foods[i].y) < c.r) {
                    c.r += 14/c.r; broadcast({type: 'eat_food', foodId: foods[i].id}); foods.splice(i, 1);
                }
            }
        });

        // æ ¸å¿ƒï¼šåˆ†å€å¡Š AI é‹ç®— (1050 è§£è„«)
        let myGridX = Math.floor(myCells[0].x / GRID_SIZE), myGridY = Math.floor(myCells[0].y / GRID_SIZE);
        let updBots = [];
        bots.forEach(b => {
            let bgX = Math.floor(b.x/GRID_SIZE), bgY = Math.floor(b.y/GRID_SIZE);
            if(Math.abs(bgX-myGridX) <= 1 && Math.abs(bgY-myGridY) <= 1) {
                let dx = myCells[0].x-b.x, dy = myCells[0].y-b.y, dist = Math.hypot(dx,dy);
                let mx = Math.random()-0.5, my = Math.random()-0.5;
                if(dist < 1800) { if(myCells[0].r > b.r) { mx=-dx; my=-dy; } else { mx=dx; my=dy; } }
                let mag = Math.hypot(mx,my); b.x += (mx/mag)*(110/b.r); b.y += (my/mag)*(110/b.r);
                updBots.push({id:b.id, x:b.x, y:b.y, r:b.r});
                
                // è¢«ç©å®¶åƒæ‰
                if(dist < myCells[0].r && myCells[0].r > b.r * 1.1) {
                    myCells[0].r += b.r * 0.18;
                    broadcast({type: 'kill_notice', msg: `${document.getElementById('user-name').value || "Fear"} åå™¬äº† ${b.name}`});
                    b.x = Math.random()*WORLD_SIZE; b.y = Math.random()*WORLD_SIZE; b.r = 40;
                }
                // åä¹‹ï¼šç©å®¶æ’åˆ°å¤§ Bot æ­»äº¡
                if(dist < b.r && b.r > myCells[0].r * 1.1) {
                    handleDeath();
                    broadcast({type: 'kill_notice', msg: `${b.name} çµ¦äº† Fear ä¸€å€‹æ·±åˆ»æ•™è¨“`});
                }
            }
        });
        if(updBots.length > 0) broadcast({type: 'grid_update', bots: updBots});
        broadcast({type: 'move', id: myId, name: document.getElementById('user-name').value || "Fear", cells: myCells});
        render();
        requestAnimationFrame(loop);
    }

    function render() {
        ctx.setTransform(1,0,0,1,0,0);
        ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width, canvas.height);
        let avgX = myCells.reduce((a,b)=>a+b.x,0)/myCells.length;
        let avgY = myCells.reduce((a,b)=>a+b.y,0)/myCells.length;
        let zoom = Math.pow(50/Math.max(...myCells.map(c=>c.r)), 0.45);
        ctx.translate(canvas.width/2, canvas.height/2); ctx.scale(zoom, zoom); ctx.translate(-avgX, -avgY);

        ctx.strokeStyle = '#330000'; ctx.lineWidth = 200; ctx.strokeRect(0,0,WORLD_SIZE,WORLD_SIZE);
        ctx.fillStyle = '#fff';
        foods.forEach(f => { if(Math.hypot(f.x-avgX, f.y-avgY) < 6000/zoom) { ctx.beginPath(); ctx.arc(f.x,f.y,20,0,7); ctx.fill(); } });

        let myName = document.getElementById('user-name').value || "Fear";
        let entities = [
            { name: myName, cells: myCells, isMe: true },
            ...Object.values(players).filter(p => p.id !== myId),
            ...bots.map(b => ({ name: b.name, cells: [{x:b.x,y:b.y,r:b.r}], isBot: true }))
        ];

        entities.forEach(p => {
            p.cells.forEach(c => {
                if(Math.hypot(c.x-avgX, c.y-avgY) > 8000/zoom) return;
                ctx.beginPath(); ctx.arc(c.x, c.y, c.r, 0, 7); 
                ctx.fillStyle = '#fff'; ctx.fill();
                ctx.fillStyle = p.isMe ? '#ff0000' : '#fff';
                ctx.font = `bold ${20 + c.r/12}px Arial`; ctx.textAlign = 'center';
                ctx.fillText(p.name, c.x, c.y);
            });
        });

        let sorted = entities.sort((a,b) => b.cells[0].r - a.cells[0].r).slice(0, 10);
        document.getElementById('lb-list').innerHTML = sorted.map((p, i) => 
            `<div style="color:${p.isMe?'#ff0000':'#fff'}">${i+1}. ${p.name.substring(0,10)} (${Math.floor(p.cells[0].r)})</div>`
        ).join('');
    }
</script>
</body>
</html>
